module Pos.PostgresConsistency.ConsistencyChecker where --FIXME: Separate into more files?

import           Universum

import           Data.List (tail)
import qualified Data.Map as Map
import qualified Database.PostgreSQL.Simple as PGS
import           Formatting (sformat)
import           System.Wlog (WithLogger, logInfo)
import           UnliftIO (MonadUnliftIO)

import           Pos.BlockchainImporter.Configuration (HasPostGresDB, postGreOperate)
import qualified Pos.BlockchainImporter.Tables.BestBlockTable as BestBlkT (getBestBlock)
import qualified Pos.BlockchainImporter.Tables.TxsTable as TxsT (TxRow, getTxByHash)
import qualified Pos.BlockchainImporter.Tables.UtxosTable as UtxosT (UtxoRow, getUtxos)
import           Pos.Core (HasConfiguration, HasPrevBlock (prevBlockL), HeaderHash, getBlockCount,
                           getChainDifficulty, headerHash)
import           Pos.Core.Block (mainBlockTxPayload)
import           Pos.Crypto (hash, hashHexF)
import           Pos.DB (MonadDBRead, getHeader, getMaxSeenDifficulty, getTipHeader)
import           Pos.DB.Block (getBlock)
import           Pos.GState.BlockExtra (resolveForwardLink)
import           Pos.PostgresConsistency.Utils
import           Pos.Txp (TxAux (..), Utxo, flattenTxPayload)
import           Pos.Txp.DB (getAllPotentiallyHugeUtxo)

type ConsistencyCheckerEnv m =
  ( HasConfiguration
  , MonadDBRead m
  , MonadIO m
  , MonadUnliftIO m
  , WithLogger m
  , HasPostGresDB
  )

{-
  Check consistency with the key-value db of a node up-to-date.
  Objective: Test consistency of the postgresdb generated after running full import,
             with the one generated in a Cardano node.
  Requires: Having the postgresdb also up-to-date
    - Checks that utxo from node are stored in postgresdb
    - Checks that tx in node from random blocks are stored postgresdb
        The random blocks to check are received as a parameter
-}
externalConsistency :: ConsistencyCheckerEnv m => [HeaderHash] -> m Bool
externalConsistency blkHashes = do
  validTxsHistory <- allTxsFromManyBlksFullfilProp isJust blkHashes
  validUtxos <- consistentUtxo
  pure $ validTxsHistory && validUtxos

{-
  Check consistency with the key-value db generated by the importer
  Objective: Test internal consistency of the importer, mainly when stopping
             it during the chain importing process.
    - Checks that utxo from importer are stored in postgresdb
    - Checks that txs in importer from (bestblock-10, bestblock] are stored in postgresdb
    - Check txs_addresses table consistency (with txs table)
    - Check best block consistency with tip block in node
 -}
internalConsistencyCheck :: ConsistencyCheckerEnv m => m Bool
internalConsistencyCheck = do
  lastNBlocks <- getLastNBlkHashes 10
  validLast10BlksTxs <- allTxsFromManyBlksFullfilProp isJust lastNBlocks
  validUtxos <- consistentUtxo
  validTxAddr <- internalConsistentTxAddr
  validBestBlock <- consistentBestBlock
  pure $ validLast10BlksTxs && validUtxos && validTxAddr && validBestBlock

{-
  Check consistency of the latest blocks with the key-value db of an up-to-date node
  Objective: Test consistency of the previous and future txs (from the point of the importer),
             with the one's stored in a Cardano node
    - Checks that tx in node from (block-10, block] are stored in postgresdb
    - Checks that tx in node from (block, block+10) are not stored in postgresdb
-}
externalConsistencyWithTxRange :: ConsistencyCheckerEnv m => HeaderHash -> m Bool
externalConsistencyWithTxRange pgTipHash = do
  prevNBlock <- getPrevNBlkHashesFromHash 10 pgTipHash
  nextNBlock <- getNextNBlkHashesFromHash 10 pgTipHash
  logInfo "Checking txs previous blocks exist"
  validPrevNBlocks <- allTxsFromManyBlksFullfilProp isJust prevNBlock
  logInfo "Checking txs previous blocks don't exist"
  validNextNBlocks <- allTxsFromManyBlksFullfilProp isNothing (tail nextNBlock)
  pure $ validPrevNBlocks && validNextNBlocks

-- Auxiliary function used for getting the tip hash
printTipHash :: ConsistencyCheckerEnv m => m ()
printTipHash = do
  tipHeader <- getTipHeader
  let tipHash = headerHash tipHeader
  print $ sformat hashHexF tipHash


-- PROPERTIES CHECKED

consistentBestBlock :: ConsistencyCheckerEnv m => m Bool
consistentBestBlock = do
  logInfo "Checking best block consistency"
  kvBestBlock <- getKVBestBlockNum
  pgBestBlock <- liftIO $ postGreOperate $ BestBlkT.getBestBlock
  let isConsistent = kvBestBlock == fromIntegral pgBestBlock
  logInfo $ toText $ if isConsistent  then "Best block is consistent"
                                      else "Best block is inconsistent: " ++
                                            "kv best block " ++ show kvBestBlock ++ "," ++
                                            "pg best block " ++ show pgBestBlock
  pure isConsistent

--FIXME: Genesis utxo not in pgUtxo, how to compare? (genesisUtxo :: HasGenesisData => GenesisUtxo)
consistentUtxo :: ConsistencyCheckerEnv m => m Bool
consistentUtxo = do
  logInfo "Checking utxo consistency"
  kvUtxos <- getAllPotentiallyHugeUtxo
  pgUtxos <- liftIO $ postGreOperate $ UtxosT.getUtxos
  let isConsistent = containsUtxo pgUtxos kvUtxos
  logInfo $ if isConsistent then "Utxo is consistent" else "Utxo is inconsistent"
  pure isConsistent

allTxsFromManyBlksFullfilProp ::
     ConsistencyCheckerEnv m
  => (Maybe TxsT.TxRow -> Bool)
  -> [HeaderHash]
  -> m Bool
allTxsFromManyBlksFullfilProp txRowProp blkHashes = do
  logInfo "Checking blk hashes consistency"
  eachFullFillProp <- mapM (allTxsFromBlkFullFilProp txRowProp) blkHashes
  let allFullfilProp = and eachFullFillProp
  logInfo $ if allFullfilProp then "blk's txs fullfil property"
                              else "blk's txs don't fullfil property"
  pure allFullfilProp

internalConsistentTxAddr :: ConsistencyCheckerEnv m => m Bool
internalConsistentTxAddr = do
  logInfo "Checking tx_addresses internal consistency"
  numberInconsistencies :: [PGS.Only Int64] <- liftIO $ postGreOperate $ (flip PGS.query_) txAddrConsistencyQuery
  let isConsistent = numberInconsistencies == [PGS.Only 0]
  logInfo $ if isConsistent then "tx_addresses table is consistent"
                            else "tx_addresses table is inconsistent"
  pure isConsistent
  where txAddrConsistencyQuery = fromString (
          "SELECT COUNT (*)" ++
          "  FROM" ++
          "  tx_addresses" ++
          "  FULL OUTER JOIN" ++
          "  (SELECT txs.hash as tx_hash, address FROM txs, unnest(txs.inputs_address) address" ++
          "  union all" ++
          "  SELECT txs.hash as tx_hash, address FROM txs, unnest(txs.outputs_address) address) as calcTxAddr" ++
          "    using (tx_hash, address)" ++
          "  WHERE calcTxAddr.tx_hash IS NULL OR tx_addresses.tx_hash IS NULL")


-- UTILS

-- FIXME: Could be improved
-- FIXME: Log blk hashes that failed
allTxsFromBlkFullFilProp ::
     ConsistencyCheckerEnv m
  => (Maybe TxsT.TxRow -> Bool)
  -> HeaderHash
  -> m Bool
allTxsFromBlkFullFilProp txRowProp blkHash = do
  maybeTxs <- getKVTxsByBlkHash blkHash
  case maybeTxs of
    Just txs -> do
      allFullfilProp <- forM txs $ \(TxAux tx _) -> do
        let txHash = hash tx
        maybeTxPGS <- liftIO $ postGreOperate $ TxsT.getTxByHash txHash
        pure $ txRowProp maybeTxPGS
      pure $ and allFullfilProp
    Nothing  -> pure False

getKVTxsByBlkHash
  :: ConsistencyCheckerEnv m
  => HeaderHash -> m (Maybe [TxAux])
getKVTxsByBlkHash blkHash = do
  maybeBlock <- getBlock blkHash
  case maybeBlock of
    Just (Right blk) ->
      pure $ Just $ flattenTxPayload $ blk ^. mainBlockTxPayload
    Just (Left _) -> pure $ Just []
    Nothing -> pure $ Nothing

getKVBestBlockNum :: ConsistencyCheckerEnv m => m Word64
getKVBestBlockNum = getBlockCount . getChainDifficulty <$> getMaxSeenDifficulty

containsUtxo :: [UtxosT.UtxoRow] -> Utxo -> Bool
containsUtxo pgUtxos kvUtxos = isNothing $ find (\row -> not $ hasUtxoRow row kvUtxos) pgUtxos

hasUtxoRow :: UtxosT.UtxoRow -> Utxo -> Bool
hasUtxoRow (txHash, idx, receiver, amount) kvUtxos = isJust $ do
  pgTxIn <- toTxIn txHash idx
  pgTxOut <- toTxOut receiver amount
  kvOut <- Map.lookup pgTxIn kvUtxos
  if show kvOut == (show pgTxOut :: String) then Just ()
                                            else Nothing
  --FIXME: Why does tx out equality doesn't work?

getLastNBlkHashes :: ConsistencyCheckerEnv m => Int -> m [HeaderHash]
getLastNBlkHashes numBlks = do
  tipHeader <- getTipHeader
  let tipHash = headerHash tipHeader
  getPrevNBlkHashesFromHash numBlks tipHash

getPrevNBlkHashesFromHash :: ConsistencyCheckerEnv m => Int -> HeaderHash -> m [HeaderHash]
getPrevNBlkHashesFromHash n initialHash = if n <= 0 then pure [] else do
  maybeInitialHeader <- getHeader initialHash
  case maybeInitialHeader of
    Just initialHeader -> do
      let prevBlockHash = initialHeader ^. prevBlockL
      (initialHash:) <$> getPrevNBlkHashesFromHash (n - 1) prevBlockHash
    Nothing ->
      pure []

-- FIXME: Improve
getNextNBlkHashesFromHash :: ConsistencyCheckerEnv m => Int -> HeaderHash -> m [HeaderHash]
getNextNBlkHashesFromHash n initialHash = if n <= 0 then pure [] else do
  maybeInitialHeader <- getHeader initialHash
  case maybeInitialHeader of
    Just initialHeader -> do
      maybeNextHeaderHash <- resolveForwardLink initialHeader
      case maybeNextHeaderHash of
        Just nextHeaderHash ->
          (initialHash:) <$> getNextNBlkHashesFromHash (n - 1) nextHeaderHash
        Nothing -> pure [initialHash]
    Nothing ->
      pure []

{-
TODO:
    Fix various FIXMEs
    Check how UtxoUndo is obtained on importer
    Improve code
    Removed unused code
-}
