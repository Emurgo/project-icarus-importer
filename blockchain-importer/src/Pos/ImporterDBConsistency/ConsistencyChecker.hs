module Pos.ImporterDBConsistency.ConsistencyChecker
  (
    externalConsistencyFromBlk
  , internalConsistencyCheck
  , externalConsistencyWithTxRange
  ) where

import           Universum

import           Data.List (tail)
import           System.Wlog (logInfo)

import qualified Pos.BlockchainImporter.Tables.TxsTable as TxsT (TxRecord)
import           Pos.Core (BlockCount (..), HasPrevBlock (prevBlockL), HasProtocolConstants,
                           HeaderHash, blkSecurityParam, headerHash)
import           Pos.DB (getHeader, getTipHeader)
import           Pos.GState.BlockExtra (resolveForwardLink)
import           Pos.ImporterDBConsistency.Properties
import           Pos.ImporterDBConsistency.Utils
import           Pos.Txp (Tx)

----------------------------------------------------------------------------
-- Checks
----------------------------------------------------------------------------

{-
  Check consistency with the key-value db of a node up-to-date.
  Objective: Test consistency of the postgresdb generated after running full import,
             with the one generated in a Cardano node.
             For sequentially doing a partial/total check of tx history consistency,
             the check is total if the starting block is the genesis block
             (hash: 89d9b5a5b8ddc8d7e5a6795e9774d97faf1efea59b2caf7eaf9f8c5b32059df4)
  Requires: Having the postgresdb also up-to-date
    - Checks that the same best block is in both the node and postgresdb
    - Checks that utxo from node are stored in postgresdb
    - Checks that tx in node from all blocks starting from a given one are stored postgresdb
-}
externalConsistencyFromBlk :: ConsistencyCheckerEnv m => HeaderHash -> m Bool
externalConsistencyFromBlk blkHashes = do
  validBestBlock <- consistentBestBlock
  validUtxos <- consistentUtxo
  validTxsHistory <- allTxsStartingFromBlk txRowExists blkHashes
  pure $ validBestBlock && validTxsHistory && validUtxos

{-
  Check consistency with the key-value db generated by the importer
  Objective: Test internal consistency of the importer, mainly when stopping
             it during the chain importing process.
    - Checks that utxo from importer are stored in postgresdb
    - Checks that txs in importer from (bestblock-blkRangeSize, bestblock]
      are stored in postgresdb
    - Check txs_addresses table consistency (with txs table)
    - Check best block consistency with tip block in node
 -}
internalConsistencyCheck :: ConsistencyCheckerEnv m => m Bool
internalConsistencyCheck = do
  lastNBlocks <- getLastNBlkHashes blkRangeSize
  validLastNBlksTxs <- allTxsFromManyBlksFullfilProp txRowExists lastNBlocks
  validUtxos <- consistentUtxo
  validTxAddr <- internalConsistentTxAddr
  validBestBlock <- consistentBestBlock
  pure $ validLastNBlksTxs && validUtxos && validTxAddr && validBestBlock

{-
  Check consistency of the latest blocks with the key-value db of an up-to-date node
  Objective: Test consistency of the previous and future txs (from the point of the importer),
             with the one's stored in a Cardano node
    - Checks that tx in node from (block-blkRangeSize, block] are stored in postgresdb
    - Checks that tx in node from (block, block+blkRangeSize) are not stored in postgresdb
-}
externalConsistencyWithTxRange :: ConsistencyCheckerEnv m => HeaderHash -> m Bool
externalConsistencyWithTxRange pgTipHash = do
  prevNBlock <- getPrevNBlkHashesFromHash blkRangeSize pgTipHash
  nextNBlock <- getNextNBlkHashesFromHash blkRangeSize pgTipHash
  logInfo "Checking txs previous blocks exist"
  validPrevNBlocks <- allTxsFromManyBlksFullfilProp txRowExists prevNBlock
  logInfo "Checking txs next blocks don't exist"
  validNextNBlocks <- allTxsFromManyBlksFullfilProp (const . isNothing) (tail nextNBlock)
  pure $ validPrevNBlocks && validNextNBlocks


----------------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------------

getLastNBlkHashes :: ConsistencyCheckerEnv m => Int -> m [HeaderHash]
getLastNBlkHashes numBlks = do
  tipHeader <- getTipHeader
  let tipHash = headerHash tipHeader
  getPrevNBlkHashesFromHash numBlks tipHash

getPrevNBlkHashesFromHash :: ConsistencyCheckerEnv m => Int -> HeaderHash -> m [HeaderHash]
getPrevNBlkHashesFromHash n initialHash = if n <= 0 then pure [] else
  maybeT (getHeader initialHash) (pure []) $ \initialHeader -> do
      let prevBlockHash = initialHeader ^. prevBlockL
      (initialHash:) <$> getPrevNBlkHashesFromHash (n - 1) prevBlockHash

getNextNBlkHashesFromHash :: ConsistencyCheckerEnv m => Int -> HeaderHash -> m [HeaderHash]
getNextNBlkHashesFromHash n initialHash = if n <= 0 then pure [] else
  maybeT (getHeader initialHash) (pure []) $ \initialHeader ->
      maybeT (resolveForwardLink initialHeader) (pure [initialHash]) $ \nextHeaderHash -> do
          hashesFromNext <- getNextNBlkHashesFromHash (n - 1) nextHeaderHash
          pure $ initialHash : hashesFromNext

{-
    Size of the range of blocks checked for tx history consistency. Selected to be 2 * k,
    the number of blocks rollbacked on every new epoch.

    This allows checking the consistency of the tx history after this process:
    - In case 'k' blocks were rollbacked and none yet applied, that none of the txs
      rollbacked is present on the db.
    - In case the 'k' blocks were already re-applied, that this process was carried
      successfully.
-}
blkRangeSize :: HasProtocolConstants => Int
blkRangeSize = 2 * k
  where k = fromIntegral $ getBlockCount blkSecurityParam

--FIXME: Maybe use getTxOut to compare txs?
txRowExists :: Maybe TxsT.TxRecord -> Tx -> Bool
txRowExists maybeTxRow _ = isJust maybeTxRow
